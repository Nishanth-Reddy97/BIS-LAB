import random

TARGET = "Hello World!"
GENE_SET = " abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!."
POPULATION_SIZE = 100
MUTATION_RATE = 0.01

def fitness(chromosome):
    # Number of matching letters in correct position
    return sum(1 for expected, actual in zip(TARGET, chromosome) if expected == actual)

def random_chromosome():
    return ''.join(random.choices(GENE_SET, k=len(TARGET)))

def mutate(chromosome):
    chromosome = list(chromosome)
    idx = random.randrange(len(chromosome))
    chromosome[idx] = random.choice(GENE_SET)
    return ''.join(chromosome)

def crossover(parent1, parent2):
    idx = random.randint(1, len(parent1) - 2)
    child = parent1[:idx] + parent2[idx:]
    return child

def select_pair(population):
    # Tournament selection
    return random.sample(sorted(population, key=lambda x: x[7], reverse=True)[:50], 2)

# Create initial population
population = [(random_chromosome(), 0) for _ in range(POPULATION_SIZE)]
generation = 0

while True:
    # Evaluate fitness for each chromosome
    population = [(chrom, fitness(chrom)) for chrom, _ in population]
    # Check for solution
    best_chrom, best_fit = max(population, key=lambda x: x[7])
    print(f"Generation {generation}: {best_chrom} Fitness: {best_fit}")
    if best_fit == len(TARGET):
        break

    # Create next generation
    next_generation = []
    while len(next_generation) < POPULATION_SIZE:
        parent1, parent2 = select_pair(population)
        child = crossover(parent1, parent2)
        if random.random() < MUTATION_RATE:
            child = mutate(child)
        next_generation.append((child, 0))  # Fitness will be recalculated

    # Move to next generation
    population = next_generation
    generation += 1
